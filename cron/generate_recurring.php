<?php
// cron/generate_recurring.php
// This script is designed to be run automatically by a cron job once per day.

echo "Starting recurring transaction generation...\n";

// --- 1. BOOTSTRAP a minimal environment ---
// We need to connect to the database, but we don't need the whole Flight framework.

// IMPORTANT: Update these with your actual database credentials from your config
$db_host = 'mysql-200-139.mysql.prositehosting.net';
$db_name = 'visubudget';
$db_user = 'visubudget';
$db_pass = 'vbuser7623';

try {
    $db = new PDO("mysql:host=$db_host;dbname=$db_name", $db_user, $db_pass);
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    $db->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
} catch (PDOException $e) {
    // Use error_log for cron jobs instead of die() for better logging
    error_log("ERROR: Could not connect to the database. " . $e->getMessage());
    exit(1); // Exit with a non-zero status code to indicate failure
}

// --- 2. LOGIC ---

// Get all active recurring rules from the database.
$stmt = $db->query("SELECT * FROM recurring_rules WHERE end_date IS NULL OR end_date >= CURDATE()");
$active_rules = $stmt->fetchAll();

echo "Found " . count($active_rules) . " active rules to process.\n";

$transactions_created = 0;

// Get today's date, with time set to midnight, for accurate comparisons.
$today = new DateTime('today');

foreach ($active_rules as $rule) {
    // Determine the look-ahead period.
    $look_ahead_date = new DateTime('now + 3 months');

    // Find the date of the last transaction generated by this rule, if any.
    $last_gen_stmt = $db->prepare("SELECT MAX(transaction_date) as last_date FROM transactions WHERE rule_id = ?");
    $last_gen_stmt->execute([$rule['rule_id']]);
    $last_date_result = $last_gen_stmt->fetch();
    
    // Determine the starting point for our calculation loop.
    $calc_start_date = new DateTime($rule['start_date']);
    if ($last_date_result && $last_date_result['last_date']) {
        // If we've generated before, start calculating from the day after the last one.
        $calc_start_date = new DateTime($last_date_result['last_date']);
    }

    $occurrences_count_stmt = $db->prepare("SELECT COUNT(*) as count FROM transactions WHERE rule_id = ?");
    $occurrences_count_stmt->execute([$rule['rule_id']]);
    $generated_count = (int)$occurrences_count_stmt->fetchColumn();

    // Loop and generate future transactions until we reach our look-ahead date
    $next_date = $calc_start_date;
    while ($next_date <= $look_ahead_date) {
        
        $next_date = calculate_next_date($next_date, $rule);

        // If calculate_next_date returns null or goes past the look-ahead, stop.
        if ($next_date === null || $next_date > $look_ahead_date) {
            break;
        }

        // --- CHECK END CONDITIONS ---
        // 1. Check if the rule has an end_date and we've passed it.
        if ($rule['end_date'] && $next_date > new DateTime($rule['end_date'])) {
            break; 
        }
        // 2. Check if the rule has a limited number of occurrences.
        if ($rule['occurrences'] > 0 && $generated_count >= $rule['occurrences']) {
            break;
        }
        
        // Only insert if the transaction is in the future or today
        if ($next_date >= $today) {
            // Check if a transaction for this rule on this specific date already exists to prevent duplicates.
            $exists_stmt = $db->prepare("SELECT COUNT(*) FROM transactions WHERE rule_id = ? AND transaction_date = ?");
            $exists_stmt->execute([$rule['rule_id'], $next_date->format('Y-m-d')]);

            if ($exists_stmt->fetchColumn() == 0) {
                 // Insert the new transaction record
                $insert_stmt = $db->prepare(
                    "INSERT INTO transactions (user_id, rule_id, description, amount, type, from_account_id, to_account_id, transaction_date, is_recurring)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1)" // Set is_recurring to true
                );
                $insert_stmt->execute([
                    $rule['user_id'],
                    $rule['rule_id'],
                    $rule['description'],
                    $rule['amount'],
                    $rule['type'],
                    $rule['from_account_id'],
                    $rule['to_account_id'],
                    $next_date->format('Y-m-d')
                ]);
                $transactions_created++;
                $generated_count++;
                echo "  -> Generated transaction for '{$rule['description']}' on " . $next_date->format('Y-m-d') . "\n";
            }
        }
    }
}

echo "Finished. Created $transactions_created new transactions.\n";

/**
 * FIXED: Helper function to calculate the next occurrence date based on a rule.
 *
 * @param DateTime $from_date The date to start calculating from.
 * @param array $rule The recurring_rule data.
 * @return DateTime|null The next calculated date.
 */
function calculate_next_date(DateTime $from_date, array $rule): ?DateTime {
    // --- FIX: Clone the date object to prevent modifying the original one ---
    $next_date = clone $from_date;
    $interval_value = (int)$rule['interval_value'];
    
    // Ensure interval is at least 1 to prevent infinite loops
    if ($interval_value < 1) {
        $interval_value = 1;
    }

    switch ($rule['frequency']) {
        case 'daily':
            $next_date->modify("+$interval_value day");
            return $next_date;

        case 'weekly':
            $next_date->modify("+$interval_value week");
            // If a specific day of the week is required, adjust to that day.
            if ($rule['day_of_week']) {
                $day_map = [1 => 'Sunday', 2 => 'Monday', 3 => 'Tuesday', 4 => 'Wednesday', 5 => 'Thursday', 6 => 'Friday', 7 => 'Saturday'];
                $target_day_name = $day_map[$rule['day_of_week']];
                $current_day_number = $next_date->format('N'); // ISO-8601 format (1 for Monday through 7 for Sunday)
                
                // Adjust PHP's day number (1-7 for Mon-Sun) to match the database's (1-7 for Sun-Sat)
                $db_day_of_week = ($current_day_number % 7) + 1;

                if ($db_day_of_week != $rule['day_of_week']) {
                     $next_date->modify($target_day_name);
                }
            }
            return $next_date;
            
        case 'monthly':
            $next_date->modify("+$interval_value month");
            return $next_date;

        case 'yearly':
            $next_date->modify("+$interval_value year");
            return $next_date;
            
        default:
            return null;
    }
}
