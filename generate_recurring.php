<?php
// cron/generate_transactions.php
// This script is designed to be run automatically by a cron job once per day.

echo "Starting recurring transaction generation...\n";

// --- 1. BOOTSTRAP a minimal environment ---
// We need to connect to the database, but we don't need the whole Flight framework.

// IMPORTANT: Update these with your actual database credentials
$db_host = 'localhost';
$db_name = 'visubudget';
$db_user = 'visubudget';
$db_pass = 'visubudget';

try {
    $db = new PDO("mysql:host=$db_host;dbname=$db_name", $db_user, $db_pass);
    $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    $db->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
} catch (PDOException $e) {
    die("ERROR: Could not connect to the database. " . $e->getMessage() . "\n");
}

// --- 2. LOGIC ---

// Get all active recurring rules from the database.
// A rule is "active" if it doesn't have an end_date or the end_date is in the future.
$stmt = $db->query("SELECT * FROM recurring_rules WHERE end_date IS NULL OR end_date >= CURDATE()");
$active_rules = $stmt->fetchAll();

echo "Found " . count($active_rules) . " active rules to process.\n";

$transactions_created = 0;

foreach ($active_rules as $rule) {
    // Determine the look-ahead period. Let's generate transactions for the next 3 months.
    $look_ahead_date = new DateTime('now + 3 months');
    $current_date = new DateTime($rule['start_date']);
    
    // Find the date of the last transaction generated by this rule, if any.
    $last_gen_stmt = $db->prepare("SELECT MAX(transaction_date) as last_date FROM transactions WHERE rule_id = ?");
    $last_gen_stmt->execute([$rule['rule_id']]);
    $last_date_result = $last_gen_stmt->fetch();
    
    if ($last_date_result && $last_date_result['last_date']) {
        // If we've already generated transactions, start calculating from the day after the last one.
        $current_date = new DateTime($last_date_result['last_date'] . ' +1 day');
    }

    $occurrences_count_stmt = $db->prepare("SELECT COUNT(*) as count FROM transactions WHERE rule_id = ?");
    $occurrences_count_stmt->execute([$rule['rule_id']]);
    $generated_count = $occurrences_count_stmt->fetchColumn();


    // Loop and generate future transactions until we reach our look-ahead date
    while ($current_date <= $look_ahead_date) {
        
        // --- CHECK END CONDITIONS ---
        // 1. Check if the rule has an end_date and we've passed it.
        if ($rule['end_date'] && $current_date > new DateTime($rule['end_date'])) {
            break; // Stop processing this rule
        }
        // 2. Check if the rule has a limited number of occurrences.
        if ($rule['occurrences'] && $generated_count >= $rule['occurrences']) {
            break; // Stop processing this rule
        }

        // Calculate the next transaction date based on the rule's frequency.
        $next_transaction_date = calculate_next_date($current_date, $rule);

        if ($next_transaction_date > $look_ahead_date) {
            break; // Don't generate transactions beyond our look-ahead period
        }
        
        // If the calculated date is valid, create the transaction
        if ($next_transaction_date) {
            // Check if a transaction for this rule on this specific date already exists to prevent duplicates.
            $exists_stmt = $db->prepare("SELECT COUNT(*) FROM transactions WHERE rule_id = ? AND transaction_date = ?");
            $exists_stmt->execute([$rule['rule_id'], $next_transaction_date->format('Y-m-d')]);

            if ($exists_stmt->fetchColumn() == 0) {
                 // Insert the new transaction record
                $insert_stmt = $db->prepare(
                    "INSERT INTO transactions (user_id, rule_id, description, amount, type, from_account_id, to_account_id, transaction_date)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
                );
                $insert_stmt->execute([
                    $rule['user_id'],
                    $rule['rule_id'],
                    $rule['description'],
                    $rule['amount'],
                    $rule['type'],
                    $rule['from_account_id'],
                    $rule['to_account_id'],
                    $next_transaction_date->format('Y-m-d')
                ]);
                $transactions_created++;
                $generated_count++;
                echo "  -> Generated transaction for '{$rule['description']}' on " . $next_transaction_date->format('Y-m-d') . "\n";
            }
        }
        
        // Move to the next potential date to check
        $current_date = $next_transaction_date;
    }
}

echo "Finished. Created $transactions_created new transactions.\n";


/**
 * Helper function to calculate the next occurrence date based on a rule.
 *
 * @param DateTime $from_date The date to start calculating from.
 * @param array $rule The recurring_rule data.
 * @return DateTime|null The next calculated date.
 */
function calculate_next_date(DateTime $from_date, array $rule) {
    $interval_value = (int)$rule['interval_value'];
    
    switch ($rule['frequency']) {
        case 'weekly':
            // Modify date to be 'next Thursday' or similar, then add the interval weeks.
            if ($rule['day_of_week']) {
                $day_names = [1 => 'Sunday', 2 => 'Monday', 3 => 'Tuesday', 4 => 'Wednesday', 5 => 'Thursday', 6 => 'Friday', 7 => 'Saturday'];
                $target_day = $day_names[$rule['day_of_week']];
                // Find the next target day based on the interval
                $from_date->modify('+' . ($interval_value -1) . ' weeks');
                $from_date->modify('next ' . $target_day);

            } else { // if no day of week is set, just add weeks.
                 $from_date->modify("+$interval_value week");
            }
            return $from_date;
            
        case 'monthly':
            $from_date->modify("+$interval_value month");
            return $from_date;

        case 'yearly':
            $from_date->modify("+$interval_value year");
            return $from_date;
            
        default:
            return null;
    }
}